/**
 * Minified by jsDelivr using Terser v5.17.1.
 * Original file: /npm/pixi-projection@1.0.0/dist/pixi-projection.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * pixi-projection - v1.0.0
 * Compiled Mon, 24 Apr 2023 10:12:46 UTC
 *
 * pixi-projection is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Popelyshev, All Rights Reserved
 */
this.PIXI = this.PIXI || {}, this.PIXI.projection = function (t, e, r, i, s, a, o, n, h, l, c) { "use strict"; var u, d = ((u = d || {})[u.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", u[u.WEBGL = 1] = "WEBGL", u[u.WEBGL2 = 2] = "WEBGL2", u), p = (t => (t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS", t))(p || {}), _ = (t => (t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL", t))(_ || {}), m = (t => (t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR", t))(m || {}), y = (t => (t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t))(y || {}), f = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(f || {}), x = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(x || {}), T = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(T || {}), v = (t => (t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT", t))(v || {}), I = (t => (t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR", t))(I || {}), g = (t => (t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t))(g || {}), E = (t => (t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL", t))(E || {}), w = (t => (t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", t))(w || {}), D = (t => (t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT", t))(D || {}), M = (t => (t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL", t))(M || {}), A = (t => (t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp", t))(A || {}), N = (t => (t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE", t[t.COLOR = 4] = "COLOR", t))(N || {}), P = (t => (t[t.RED = 1] = "RED", t[t.GREEN = 2] = "GREEN", t[t.BLUE = 4] = "BLUE", t[t.ALPHA = 8] = "ALPHA", t))(P || {}), S = (t => (t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH", t))(S || {}), R = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(R || {}); class b extends e.Geometry { constructor(t = !1) { super(), this._buffer = new e.Buffer(null, t, !1), this._indexBuffer = new e.Buffer(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 3, !1, T.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, T.FLOAT).addAttribute("aColor", this._buffer, 4, !0, T.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, T.FLOAT).addIndex(this._indexBuffer) } } class j extends e.BatchRenderer { constructor(t) { super(t), this.geometryClass = b, this.vertexSize = 7 } setShaderGenerator() { this.shaderGenerator = new e.BatchShaderGenerator("precision highp float;\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * aVertexPosition;\ngl_Position.z = 0.0;\n\nvTextureCoord = aTextureCoord;\nvTextureId = aTextureId;\nvColor = aColor;\n}\n", "\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\nvec4 color;\n%forloop%\ngl_FragColor = color * vColor;\n}") } packInterleavedGeometry(t, r, i, s, a) { const { uint32View: o, float32View: n } = r, h = s / this.vertexSize, l = t.uvs, c = t.indices, u = t.vertexData, d = t.vertexData2d, p = t._texture.baseTexture._batchLocation, _ = Math.min(t.worldAlpha, 1), m = e.Color.shared.setValue(t._tintRGB).toPremultiplied(_); if (d) { let t = 0; for (let e = 0; e < d.length; e += 3, t += 2)n[s++] = d[e], n[s++] = d[e + 1], n[s++] = d[e + 2], n[s++] = l[t], n[s++] = l[t + 1], o[s++] = m, n[s++] = p } else for (let t = 0; t < u.length; t += 2)n[s++] = u[t], n[s++] = u[t + 1], n[s++] = 1, n[s++] = l[t], n[s++] = l[t + 1], o[s++] = m, n[s++] = p; for (let t = 0; t < c.length; t++)i[a++] = h + c[t] } } j.extension = { name: "batch2d", type: e.ExtensionType.RendererPlugin }; class L { constructor(t, e = !0) { this._enabled = !1, this.legacy = t, e && (this.enabled = !0), this.legacy.proj = this } get enabled() { return this._enabled } set enabled(t) { this._enabled = t } clear() { } } var C = (t => (t[t.NONE = 0] = "NONE", t[t.BEFORE_PROJ = 4] = "BEFORE_PROJ", t[t.PROJ = 5] = "PROJ", t[t.ALL = 9] = "ALL", t))(C || {}), O = (t => (t[t.NONE = 0] = "NONE", t[t.FREE = 1] = "FREE", t[t.AXIS_X = 2] = "AXIS_X", t[t.AXIS_Y = 3] = "AXIS_Y", t[t.POINT = 4] = "POINT", t[t.AXIS_XR = 5] = "AXIS_XR", t))(O || {}); function F(t) { const e = this.proj, r = this, i = t._worldID, s = r.localTransform, a = e.scaleAfterAffine && e.affine >= 2; r._localID !== r._currentLocalID && (a ? (s.a = r._cx, s.b = r._sx, s.c = r._cy, s.d = r._sy, s.tx = r.position._x, s.ty = r.position._y) : (s.a = r._cx * r.scale._x, s.b = r._sx * r.scale._x, s.c = r._cy * r.scale._y, s.d = r._sy * r.scale._y, s.tx = r.position._x - (r.pivot._x * s.a + r.pivot._y * s.c), s.ty = r.position._y - (r.pivot._x * s.b + r.pivot._y * s.d)), r._currentLocalID = r._localID, e._currentProjID = -1); const o = e._projID; if (e._currentProjID !== o && (e._currentProjID = o, e.updateLocalTransform(s), r._parentID = -1), r._parentID !== i) { const s = t.proj; s && !s._affine ? e.world.setToMult(s.world, e.local) : e.world.setToMultLegacy(t.worldTransform, e.local); const o = r.worldTransform; e.world.copyTo(o, e._affine, e.affinePreserveOrientation), a && (o.a *= r.scale._x, o.b *= r.scale._x, o.c *= r.scale._y, o.d *= r.scale._y, o.tx -= r.pivot._x * o.a + r.pivot._y * o.c, o.ty -= r.pivot._x * o.b + r.pivot._y * o.d), r._parentID = i, r._worldID++ } } class U extends L { constructor() { super(...arguments), this._projID = 0, this._currentProjID = -1, this._affine = 0, this.affinePreserveOrientation = !1, this.scaleAfterAffine = !0 } updateLocalTransform(t) { } set affine(t) { this._affine !== t && (this._affine = t, this._currentProjID = -1, this.legacy._currentLocalID = -1) } get affine() { return this._affine } set enabled(t) { t !== this._enabled && (this._enabled = t, t ? (this.legacy.updateTransform = F, this.legacy._parentID = -1) : (this.legacy.updateTransform = r.Transform.prototype.updateTransform, this.legacy._parentID = -1)) } clear() { this._currentProjID = -1, this._projID = 0 } } class B extends e.BatchRenderer { constructor() { super(...arguments), this.forceMaxTextures = 0, this.defUniforms = {} } getUniforms(t) { return this.defUniforms } syncUniforms(t) { if (!t) return; const e = this._shader; for (const r in t) e.uniforms[r] = t[r] } buildDrawCalls(t, r, s) { const a = this, { _bufferedElements: o, _attributeBuffer: n, _indexBuffer: h, vertexSize: l } = this, c = e.BatchRenderer._drawCallPool; let u = this._dcIndex, d = this._aIndex, p = this._iIndex, _ = c[u]; _.start = this._iIndex, _.texArray = t; for (let e = r; e < s; ++e) { const s = o[e], a = s._texture.baseTexture, m = i.premultiplyBlendMode[a.alphaMode ? 1 : 0][s.blendMode], y = this.getUniforms(s); o[e] = null, r < e && (_.blend !== m || _.uniforms !== y) && (_.size = p - _.start, r = e, _ = c[++u], _.texArray = t, _.start = p), this.packInterleavedGeometry(s, n, h, d, p), d += s.vertexData.length / 2 * l, p += s.indices.length, _.blend = m, _.uniforms = y } r < s && (_.size = p - _.start, ++u), a._dcIndex = u, a._aIndex = d, a._iIndex = p } drawBatches() { const t = this._dcIndex, { gl: r, state: i, shader: s } = this.renderer, a = e.BatchRenderer._drawCallPool; let o = null, n = null; for (let e = 0; e < t; e++) { const { texArray: t, type: h, size: l, start: c, blend: u, uniforms: d } = a[e]; n !== t && (n = t, this.bindAndClearTexArray(t)), o !== d && (o = d, this.syncUniforms(d), s.syncUniformGroup(this._shader.uniformGroup)), this.state.blendMode = u, i.set(this.state), r.drawElements(h, l, r.UNSIGNED_SHORT, 2 * c) } } contextChange() { if (!this.forceMaxTextures) return super.contextChange(), void this.syncUniforms(this.defUniforms); const t = this; t.maxTextures = this.forceMaxTextures, this._shader = t.shaderGenerator.generateShader(this.maxTextures), this.syncUniforms(this.defUniforms); for (let e = 0; e < t._packedGeometryPoolSize; e++)t._packedGeometries[e] = new this.geometryClass; this.initFlushBuffers() } } function G(t, e, r, i, s) { const a = e.x - t.x, o = r.x - i.x, n = r.x - t.x, h = e.y - t.y, l = r.y - i.y, c = r.y - t.y, u = a * l - h * o; if (Math.abs(u) < 1e-7) return s.x = a, s.y = h, 0; const d = (n * l - c * o) / u, p = (a * c - h * n) / u; return p < 1e-6 || p - 1 > -1e-6 ? -1 : (s.x = t.x + d * (e.x - t.x), s.y = t.y + d * (e.y - t.y), 1) } e.extensions.add(j); const V = [1, 0, 0, 0, 1, 0, 0, 0, 1], z = class { constructor(t) { this.floatArray = null, this.mat3 = new Float64Array(t || V) } get a() { return this.mat3[0] / this.mat3[8] } set a(t) { this.mat3[0] = t * this.mat3[8] } get b() { return this.mat3[1] / this.mat3[8] } set b(t) { this.mat3[1] = t * this.mat3[8] } get c() { return this.mat3[3] / this.mat3[8] } set c(t) { this.mat3[3] = t * this.mat3[8] } get d() { return this.mat3[4] / this.mat3[8] } set d(t) { this.mat3[4] = t * this.mat3[8] } get tx() { return this.mat3[6] / this.mat3[8] } set tx(t) { this.mat3[6] = t * this.mat3[8] } get ty() { return this.mat3[7] / this.mat3[8] } set ty(t) { this.mat3[7] = t * this.mat3[8] } set(t, e, r, i, s, a) { const o = this.mat3; return o[0] = t, o[1] = e, o[2] = 0, o[3] = r, o[4] = i, o[5] = 0, o[6] = s, o[7] = a, o[8] = 1, this } toArray(t, e) { this.floatArray || (this.floatArray = new Float32Array(9)); const r = e || this.floatArray, i = this.mat3; return t ? (r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[4] = i[4], r[5] = i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8]) : (r[0] = i[0], r[1] = i[3], r[2] = i[6], r[3] = i[1], r[4] = i[4], r[5] = i[7], r[6] = i[2], r[7] = i[5], r[8] = i[8]), r } apply(t, e) { e = e || new r.Point; const i = this.mat3, s = t.x, a = t.y, o = 1 / (i[2] * s + i[5] * a + i[8]); return e.x = o * (i[0] * s + i[3] * a + i[6]), e.y = o * (i[1] * s + i[4] * a + i[7]), e } translate(t, e) { const r = this.mat3; return r[0] += t * r[2], r[1] += e * r[2], r[3] += t * r[5], r[4] += e * r[5], r[6] += t * r[8], r[7] += e * r[8], this } scale(t, e) { const r = this.mat3; return r[0] *= t, r[1] *= e, r[3] *= t, r[4] *= e, r[6] *= t, r[7] *= e, this } scaleAndTranslate(t, e, r, i) { const s = this.mat3; s[0] = t * s[0] + r * s[2], s[1] = e * s[1] + i * s[2], s[3] = t * s[3] + r * s[5], s[4] = e * s[4] + i * s[5], s[6] = t * s[6] + r * s[8], s[7] = e * s[7] + i * s[8] } applyInverse(t, e) { e = e || new r.Point; const i = this.mat3, s = t.x, a = t.y, o = i[0], n = i[3], h = i[6], l = i[1], c = i[4], u = i[7], d = i[2], p = i[5], _ = i[8], m = (_ * c - u * p) * s + (-_ * n + h * p) * a + (u * n - h * c), y = (-_ * l + u * d) * s + (_ * o - h * d) * a + (-u * o + h * l), f = (p * l - c * d) * s + (-p * o + n * d) * a + (c * o - n * l); return e.x = m / f, e.y = y / f, e } invert() { const t = this.mat3, e = t[0], r = t[1], i = t[2], s = t[3], a = t[4], o = t[5], n = t[6], h = t[7], l = t[8], c = l * a - o * h, u = -l * s + o * n, d = h * s - a * n; let p = e * c + r * u + i * d; return p ? (p = 1 / p, t[0] = c * p, t[1] = (-l * r + i * h) * p, t[2] = (o * r - i * a) * p, t[3] = u * p, t[4] = (l * e - i * n) * p, t[5] = (-o * e + i * s) * p, t[6] = d * p, t[7] = (-h * e + r * n) * p, t[8] = (a * e - r * s) * p, this) : this } identity() { const t = this.mat3; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this } clone() { return new z(this.mat3) } copyTo2dOr3d(t) { const e = this.mat3, r = t.mat3; return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], t } copyTo(t, e, r) { const i = this.mat3, s = 1 / i[8], a = i[6] * s, o = i[7] * s; if (t.a = (i[0] - i[2] * a) * s, t.b = (i[1] - i[2] * o) * s, t.c = (i[3] - i[5] * a) * s, t.d = (i[4] - i[5] * o) * s, t.tx = a, t.ty = o, e >= 2) { let i = t.a * t.d - t.b * t.c; r || (i = Math.abs(i)), e === O.POINT ? (i = i > 0 ? 1 : -1, t.a = i, t.b = 0, t.c = 0, t.d = i) : e === O.AXIS_X ? (i /= Math.sqrt(t.b * t.b + t.d * t.d), t.c = 0, t.d = i) : e === O.AXIS_Y ? (i /= Math.sqrt(t.a * t.a + t.c * t.c), t.a = i, t.c = 0) : e === O.AXIS_XR && (t.a = t.d * i, t.c = -t.b * i) } return t } copyFrom(t) { const e = this.mat3; return e[0] = t.a, e[1] = t.b, e[2] = 0, e[3] = t.c, e[4] = t.d, e[5] = 0, e[6] = t.tx, e[7] = t.ty, e[8] = 1, this } setToMultLegacy(t, e) { const r = this.mat3, i = e.mat3, s = t.a, a = t.b, o = t.c, n = t.d, h = t.tx, l = t.ty, c = i[0], u = i[1], d = i[2], p = i[3], _ = i[4], m = i[5], y = i[6], f = i[7], x = i[8]; return r[0] = c * s + u * o + d * h, r[1] = c * a + u * n + d * l, r[2] = d, r[3] = p * s + _ * o + m * h, r[4] = p * a + _ * n + m * l, r[5] = m, r[6] = y * s + f * o + x * h, r[7] = y * a + f * n + x * l, r[8] = x, this } setToMultLegacy2(t, e) { const r = this.mat3, i = t.mat3, s = i[0], a = i[1], o = i[2], n = i[3], h = i[4], l = i[5], c = i[6], u = i[7], d = i[8], p = e.a, _ = e.b, m = e.c, y = e.d, f = e.tx, x = e.ty; return r[0] = p * s + _ * n, r[1] = p * a + _ * h, r[2] = p * o + _ * l, r[3] = m * s + y * n, r[4] = m * a + y * h, r[5] = m * o + y * l, r[6] = f * s + x * n + c, r[7] = f * a + x * h + u, r[8] = f * o + x * l + d, this } setToMult(t, e) { const r = this.mat3, i = t.mat3, s = e.mat3, a = i[0], o = i[1], n = i[2], h = i[3], l = i[4], c = i[5], u = i[6], d = i[7], p = i[8], _ = s[0], m = s[1], y = s[2], f = s[3], x = s[4], T = s[5], v = s[6], I = s[7], g = s[8]; return r[0] = _ * a + m * h + y * u, r[1] = _ * o + m * l + y * d, r[2] = _ * n + m * c + y * p, r[3] = f * a + x * h + T * u, r[4] = f * o + x * l + T * d, r[5] = f * n + x * c + T * p, r[6] = v * a + I * h + g * u, r[7] = v * o + I * l + g * d, r[8] = v * n + I * c + g * p, this } prepend(t) { return t.mat3 ? this.setToMult(t, this) : this.setToMultLegacy(t, this) } }; let X = z; X.IDENTITY = new z, X.TEMP_MATRIX = new z; const q = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec3 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\n\nvTextureCoord = uTransform * vec3(aTextureCoord, 1.0);\n}\n", H = new X; class k extends e.ObjectRenderer { constructor(t) { super(t), this.quad = new e.QuadUv; const r = { globals: this.renderer.globalUniforms }; this.shader = e.Shader.from(q, "\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\nvec2 coord = mod(vTextureCoord.xy / vTextureCoord.z - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\ncoord = (uMapCoord * vec3(coord, 1.0)).xy;\ncoord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\nvec4 sample = texture2D(uSampler, coord);\ngl_FragColor = sample * uColor;\n}\n", r), this.simpleShader = e.Shader.from(q, "\nvarying vec3 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\nvec4 sample = texture2D(uSampler, vTextureCoord.xy / vTextureCoord.z);\ngl_FragColor = sample * uColor;\n}\n", r) } render(t) { const e = this.renderer, r = this.quad; let s = r.vertices; s[0] = s[6] = t._width * -t.anchor.x, s[1] = s[3] = t._height * -t.anchor.y, s[2] = s[4] = t._width * (1 - t.anchor.x), s[5] = s[7] = t._height * (1 - t.anchor.y), t.uvRespectAnchor && (s = r.uvs, s[0] = s[6] = -t.anchor.x, s[1] = s[3] = -t.anchor.y, s[2] = s[4] = 1 - t.anchor.x, s[5] = s[7] = 1 - t.anchor.y), r.invalidate(); const a = t._texture, o = a.baseTexture, n = t.tileProj.world, h = t.uvMatrix; let l = o.isPowerOfTwo && a.frame.width === o.width && a.frame.height === o.height; l && (o._glTextures[e.CONTEXT_UID] ? l = o.wrapMode !== g.CLAMP : o.wrapMode === g.CLAMP && (o.wrapMode = g.REPEAT)); const c = l ? this.simpleShader : this.shader; H.identity(), H.scale(a.width, a.height), H.prepend(n), H.scale(1 / t._width, 1 / t._height), H.invert(), l ? H.prepend(h.mapCoord) : (c.uniforms.uMapCoord = h.mapCoord.toArray(!0), c.uniforms.uClampFrame = h.uClampFrame, c.uniforms.uClampOffset = h.uClampOffset), c.uniforms.uTransform = H.toArray(!0), c.uniforms.uColor = i.premultiplyTintToRgba(t.tint, t.worldAlpha, c.uniforms.uColor, o.premultiplyAlpha), c.uniforms.translationMatrix = t.worldTransform.toArray(!0), c.uniforms.uSampler = a, e.shader.bind(c, !1), e.geometry.bind(r, void 0), e.state.setBlendMode(i.correctBlendMode(t.blendMode, o.premultiplyAlpha)), e.geometry.draw(y.TRIANGLES, 6, 0) } } k.extension = { name: "tilingSprite2d", type: e.ExtensionType.RendererPlugin }; const Y = new r.Point, W = [new r.Point, new r.Point, new r.Point, new r.Point], Q = new r.Rectangle, J = new X; class K extends U { constructor(t, e) { super(t, e), this.matrix = new X, this.pivot = new r.ObservablePoint(this.onChange, this, 0, 0), this.reverseLocalOrder = !1, this.local = new X, this.world = new X } onChange() { const t = this.pivot, e = this.matrix.mat3; e[6] = -(t._x * e[0] + t._y * e[3]), e[7] = -(t._x * e[1] + t._y * e[4]), this._projID++ } setAxisX(t, e = 1) { const r = t.x, i = t.y, s = Math.sqrt(r * r + i * i), a = this.matrix.mat3; a[0] = r / s, a[1] = i / s, a[2] = e / s, this.onChange() } setAxisY(t, e = 1) { const r = t.x, i = t.y, s = Math.sqrt(r * r + i * i), a = this.matrix.mat3; a[3] = r / s, a[4] = i / s, a[5] = e / s, this.onChange() } mapSprite(t, e) { const r = t.texture; Q.x = -t.anchor.x * r.orig.width, Q.y = -t.anchor.y * r.orig.height, Q.width = r.orig.width, Q.height = r.orig.height, this.mapQuad(Q, e) } mapQuad(t, e) { W[0].set(t.x, t.y), W[1].set(t.x + t.width, t.y), W[2].set(t.x + t.width, t.y + t.height), W[3].set(t.x, t.y + t.height); let r = 1, i = 2, s = 3; if (0 === G(e[0], e[2], e[1], e[3], Y)) return; r = 1, i = 3, s = 2; const a = Math.sqrt((e[0].x - Y.x) * (e[0].x - Y.x) + (e[0].y - Y.y) * (e[0].y - Y.y)), o = Math.sqrt((e[r].x - Y.x) * (e[r].x - Y.x) + (e[r].y - Y.y) * (e[r].y - Y.y)), n = Math.sqrt((e[i].x - Y.x) * (e[i].x - Y.x) + (e[i].y - Y.y) * (e[i].y - Y.y)), h = Math.sqrt((e[s].x - Y.x) * (e[s].x - Y.x) + (e[s].y - Y.y) * (e[s].y - Y.y)), l = (a + h) / h, c = (o + n) / n, u = (o + n) / o; let d = this.matrix.mat3; d[0] = W[0].x * l, d[1] = W[0].y * l, d[2] = l, d[3] = W[r].x * c, d[4] = W[r].y * c, d[5] = c, d[6] = W[i].x * u, d[7] = W[i].y * u, d[8] = u, this.matrix.invert(), d = J.mat3, d[0] = e[0].x, d[1] = e[0].y, d[2] = 1, d[3] = e[r].x, d[4] = e[r].y, d[5] = 1, d[6] = e[i].x, d[7] = e[i].y, d[8] = 1, this.matrix.setToMult(J, this.matrix), this._projID++ } updateLocalTransform(t) { 0 !== this._projID ? this.reverseLocalOrder ? this.local.setToMultLegacy2(this.matrix, t) : this.local.setToMultLegacy(t, this.matrix) : this.local.copyFrom(t) } clear() { super.clear(), this.matrix.identity(), this.pivot.set(0, 0) } } function Z() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } class $ extends s.Container { constructor() { super(), this.proj = new K(this.transform) } toLocal(t, e, r, i, s = C.ALL) { return e && (t = e.toGlobal(t, r, i)), i || this._recursivePostUpdateTransform(), s >= C.PROJ ? (i || this.displayObjectUpdateTransform(), this.proj.affine ? this.transform.worldTransform.applyInverse(t, r) : this.proj.world.applyInverse(t, r)) : (this.parent ? r = this.parent.worldTransform.applyInverse(t, r) : (r.x = t.x, r.y = t.y), s === C.NONE ? r : this.transform.localTransform.applyInverse(r, r)) } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } } const tt = $.prototype.toLocal; class et extends o.Mesh { constructor(t, e, r, i) { super(t, e, r, i), this.vertexData2d = null, this.proj = new K(this.transform) } calculateVertices() { if (this.proj._affine) return this.vertexData2d = null, void super.calculateVertices(); const t = this.geometry, e = t.buffers[0].data, r = this; if (t.vertexDirtyId === r.vertexDirty && r._transformID === r.transform._worldID) return; r._transformID = r.transform._worldID, r.vertexData.length !== e.length && (r.vertexData = new Float32Array(e.length)), (!this.vertexData2d || this.vertexData2d.length !== 3 * e.length / 2) && (this.vertexData2d = new Float32Array(3 * e.length)); const i = this.proj.world.mat3, s = this.vertexData2d, a = r.vertexData; for (let t = 0; t < a.length / 2; t++) { const r = e[2 * t], o = e[2 * t + 1], n = i[0] * r + i[3] * o + i[6], h = i[1] * r + i[4] * o + i[7], l = i[2] * r + i[5] * o + i[8]; s[3 * t] = n, s[3 * t + 1] = h, s[3 * t + 2] = l, a[2 * t] = n / l, a[2 * t + 1] = h / l } r.vertexDirty = t.vertexDirtyId } _renderDefault(t) { var e; const r = this.shader; r.alpha = this.worldAlpha, r.update && r.update(), t.batch.flush(), null != (e = r.program.uniformData) && e.translationMatrix && (r.uniforms.translationMatrix = this.worldTransform.toArray(!0)), t.shader.bind(r, !1), t.state.set(this.state), t.geometry.bind(this.geometry, r), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount) } toLocal(t, e, r, i, s = C.ALL) { return tt.call(this, t, e, r, i, s) } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } } et.defaultVertexShader = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", et.defaultFragmentShader = "\nvarying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\ngl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}"; class rt extends et { constructor(t, r, i, s, a) { super(new o.MeshGeometry(r, i, s), new o.MeshMaterial(t, { program: e.Program.from(et.defaultVertexShader, et.defaultFragmentShader), pluginName: "batch2d" }), null, a), this.autoUpdate = !0, this.geometry.getBuffer("aVertexPosition").static = !1 } get vertices() { return this.geometry.getBuffer("aVertexPosition").data } set vertices(t) { this.geometry.getBuffer("aVertexPosition").data = t } _render(t) { this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(t) } } class it extends h.Sprite { constructor(t) { super(t), this.vertexData2d = null, this.proj = new K(this.transform), this.pluginName = "batch2d" } _calculateBounds() { this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData) } calculateVertices() { const t = this._texture; if (this.proj._affine) return this.vertexData2d = null, void super.calculateVertices(); this.vertexData2d || (this.vertexData2d = new Float32Array(12)); const e = this.transform._worldID, r = t._updateID; if (this._transformID === e && this._textureID === r) return; this._textureID !== r && (this.uvs = t._uvs.uvsFloat32), this._transformID = e, this._textureID = r; const i = this.proj.world.mat3, s = this.vertexData2d, a = this.vertexData, o = t.trim, n = t.orig, h = this._anchor; let l, c, u, d; o ? (c = o.x - h._x * n.width, l = c + o.width, d = o.y - h._y * n.height, u = d + o.height) : (c = -h._x * n.width, l = c + n.width, d = -h._y * n.height, u = d + n.height), s[0] = i[0] * c + i[3] * d + i[6], s[1] = i[1] * c + i[4] * d + i[7], s[2] = i[2] * c + i[5] * d + i[8], s[3] = i[0] * l + i[3] * d + i[6], s[4] = i[1] * l + i[4] * d + i[7], s[5] = i[2] * l + i[5] * d + i[8], s[6] = i[0] * l + i[3] * u + i[6], s[7] = i[1] * l + i[4] * u + i[7], s[8] = i[2] * l + i[5] * u + i[8], s[9] = i[0] * c + i[3] * u + i[6], s[10] = i[1] * c + i[4] * u + i[7], s[11] = i[2] * c + i[5] * u + i[8], a[0] = s[0] / s[2], a[1] = s[1] / s[2], a[2] = s[3] / s[5], a[3] = s[4] / s[5], a[4] = s[6] / s[8], a[5] = s[7] / s[8], a[6] = s[9] / s[11], a[7] = s[10] / s[11] } calculateTrimmedVertices() { if (this.proj._affine) return void super.calculateTrimmedVertices(); const t = this.transform._worldID, e = this._texture._updateID, r = this; if (r.vertexTrimmedData) { if (r._transformTrimmedID === t && this._textureTrimmedID === e) return } else r.vertexTrimmedData = new Float32Array(8); r._transformTrimmedID = t, this._textureTrimmedID = e; const i = this._texture, s = r.vertexTrimmedData, a = i.orig, o = this.tileProj ? this._width : a.width, n = this.tileProj ? this._height : a.height, h = this._anchor, l = this.proj.world.mat3, c = -h._x * o, u = c + o, d = -h._y * n, p = d + n; let _ = 1 / (l[2] * c + l[5] * d + l[8]); s[0] = _ * (l[0] * c + l[3] * d + l[6]), s[1] = _ * (l[1] * c + l[4] * d + l[7]), _ = 1 / (l[2] * u + l[5] * d + l[8]), s[2] = _ * (l[0] * u + l[3] * d + l[6]), s[3] = _ * (l[1] * u + l[4] * d + l[7]), _ = 1 / (l[2] * u + l[5] * p + l[8]), s[4] = _ * (l[0] * u + l[3] * p + l[6]), s[5] = _ * (l[1] * u + l[4] * p + l[7]), _ = 1 / (l[2] * c + l[5] * p + l[8]), s[6] = _ * (l[0] * c + l[3] * p + l[6]), s[7] = _ * (l[1] * c + l[4] * p + l[7]) } toLocal(t, e, r, i, s = C.ALL) { return tt.call(this, t, e, r, i, s) } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } } const st = new r.Transform; class at extends a.TilingSprite { constructor(t, e, r) { super(t, e, r), this.tileProj = new K(this.tileTransform), this.tileProj.reverseLocalOrder = !0, this.proj = new K(this.transform), this.pluginName = "tilingSprite2d", this.uvRespectAnchor = !0 } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } toLocal(t, e, r, i, s = C.ALL) { return tt.call(this, t, e, r, i, s) } _render(t) { const e = this._texture; !e || !e.valid || (this.tileTransform.updateTransform(st), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)) } } function ot() { this.proj || (this.proj = new K(this.transform), this.toLocal = $.prototype.toLocal, Object.defineProperty(this, "worldTransform", { get: Z, enumerable: !0, configurable: !0 })) } s.Container.prototype.convertTo2d = ot, h.Sprite.prototype.convertTo2d = function () { this.proj || (this.calculateVertices = it.prototype.calculateVertices, this.calculateTrimmedVertices = it.prototype.calculateTrimmedVertices, this._calculateBounds = it.prototype._calculateBounds, this.pluginName = "batch2d", ot.call(this)) }, s.Container.prototype.convertSubtreeTo2d = function () { this.convertTo2d(); for (let t = 0; t < this.children.length; t++)this.children[t].convertSubtreeTo2d() }, n.SimpleMesh.prototype.convertTo2d = n.SimpleRope.prototype.convertTo2d = function () { this.proj || (this.calculateVertices = et.prototype.calculateVertices, this._renderDefault = et.prototype._renderDefault, "batch2d" !== this.material.pluginName && (this.material = new o.MeshMaterial(this.material.texture, { program: e.Program.from(et.defaultVertexShader, et.defaultFragmentShader), pluginName: "batch2d" })), ot.call(this)) }, a.TilingSprite.prototype.convertTo2d = function () { this.proj || (this.tileProj = new K(this.tileTransform), this.tileProj.reverseLocalOrder = !0, this.uvRespectAnchor = !0, this.calculateTrimmedVertices = it.prototype.calculateTrimmedVertices, this._calculateBounds = it.prototype._calculateBounds, this._render = at.prototype._render, this.pluginName = "tilingSprite2d", ot.call(this)) }; class nt extends l.Text { constructor(t, e, r) { super(t, e, r), this.vertexData2d = null, this.proj = new K(this.transform), this.pluginName = "batch2d" } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } } nt.prototype.calculateVertices = it.prototype.calculateVertices, nt.prototype.calculateTrimmedVertices = it.prototype.calculateTrimmedVertices, nt.prototype._calculateBounds = it.prototype._calculateBounds; const ht = new X; class lt extends e.Filter { constructor(t) { super("\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\nvTextureCoord = aTextureCoord;\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\n}\n", "\nvarying vec3 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\n\nfloat clip = step(3.5,\n    step(maskClamp.x, uv.x) +\n    step(maskClamp.y, uv.y) +\n    step(uv.x, maskClamp.z) +\n    step(uv.y, maskClamp.w));\n\nvec4 original = texture2D(uSampler, vTextureCoord);\nvec4 masky = texture2D(mask, uv);\n\noriginal *= (masky.r * masky.a * alpha * clip);\n\ngl_FragColor = original;\n}\n"), this.maskMatrix = new X, t.renderable = !1, this.maskSprite = t } apply(t, r, i, s) { const a = this.maskSprite, o = this.maskSprite.texture; o.valid && (o.uvMatrix || (o.uvMatrix = new e.TextureMatrix(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = a.texture, this.uniforms.otherMatrix = lt.calculateSpriteMatrix(r, this.maskMatrix, a).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = a.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, r, i, s)) } static calculateSpriteMatrix(t, e, r) { const i = r.proj, s = t.filterFrame, a = i && !i._affine ? i.world.copyTo2dOr3d(ht) : ht.copyFrom(r.transform.worldTransform), o = r.texture.orig; return e.set(t.width, 0, 0, t.height, s.x, s.y), a.invert(), e.setToMult(a, e), e.scaleAndTranslate(1 / o.width, 1 / o.height, r.anchor.x, r.anchor.y), e } } const ct = e.MaskSystem.prototype.pushSpriteMask; function ut(t) { const { maskObject: e } = t, r = t._filters; if (!r) { let r = this.alphaMaskPool[this.alphaMaskIndex]; r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new lt(e)]), t._filters = r } ct.call(this, t), r || (t._filters = null) } e.extensions.add(k); class dt extends r.Point { constructor(t, e, r) { super(t, e), this.z = r } set(t, e, r) { return this.x = t || 0, this.y = void 0 === e ? this.x : e || 0, this.z = void 0 === e ? this.x : r || 0, this } copyFrom(t) { return this.set(t.x, t.y, t.z || 0), this } copyTo(t) { return t.set(this.x, this.y, this.z), t } } class pt extends r.ObservablePoint { constructor() { super(...arguments), this._z = 0 } get z() { return this._z } set z(t) { this._z !== t && (this._z = t, this.cb.call(this.scope)) } set(t, e, r) { const i = t || 0, s = void 0 === e ? i : e || 0, a = void 0 === e ? i : r || 0; return (this._x !== i || this._y !== s || this._z !== a) && (this._x = i, this._y = s, this._z = a, this.cb.call(this.scope)), this } copyFrom(t) { return this.set(t.x, t.y, t.z || 0), this } copyTo(t) { return t.set(this._x, this._y, this._z), t } } class _t { constructor(t, e, r) { this._quatUpdateId = -1, this._quatDirtyId = 0, this._sign = 1, this._x = t || 0, this._y = e || 0, this._z = r || 0, this.quaternion = new Float64Array(4), this.quaternion[3] = 1, this.update() } get x() { return this._x } set x(t) { this._x !== t && (this._x = t, this._quatDirtyId++) } get y() { return this._y } set y(t) { this._y !== t && (this._y = t, this._quatDirtyId++) } get z() { return this._z } set z(t) { this._z !== t && (this._z = t, this._quatDirtyId++) } get pitch() { return this._x } set pitch(t) { this._x !== t && (this._x = t, this._quatDirtyId++) } get yaw() { return this._y } set yaw(t) { this._y !== t && (this._y = t, this._quatDirtyId++) } get roll() { return this._z } set roll(t) { this._z !== t && (this._z = t, this._quatDirtyId++) } set(t, e, r) { const i = t || 0, s = e || 0, a = r || 0; (this._x !== i || this._y !== s || this._z !== a) && (this._x = i, this._y = s, this._z = a, this._quatDirtyId++) } copyFrom(t) { const e = t.x, r = t.y, i = t.z; return (this._x !== e || this._y !== r || this._z !== i) && (this._x = e, this._y = r, this._z = i, this._quatDirtyId++), this } copyTo(t) { return t.set(this._x, this._y, this._z), t } equals(t) { return this._x === t.x && this._y === t.y && this._z === t.z } clone() { return new _t(this._x, this._y, this._z) } update() { if (this._quatUpdateId === this._quatDirtyId) return !1; this._quatUpdateId = this._quatDirtyId; const t = Math.cos(this._x / 2), e = Math.cos(this._y / 2), r = Math.cos(this._z / 2), i = this._sign, s = i * Math.sin(this._x / 2), a = i * Math.sin(this._y / 2), o = i * Math.sin(this._z / 2), n = this.quaternion; return n[0] = s * e * r + t * a * o, n[1] = t * a * r - s * e * o, n[2] = t * e * o + s * a * r, n[3] = t * e * r - s * a * o, !0 } } class mt { constructor(t, e, r, i, s) { this.cb = t, this.scope = e, this._quatUpdateId = -1, this._quatDirtyId = 0, this._sign = 1, this._x = r || 0, this._y = i || 0, this._z = s || 0, this.quaternion = new Float64Array(4), this.quaternion[3] = 1, this.update() } get x() { return this._x } set x(t) { this._x !== t && (this._x = t, this._quatDirtyId++, this.cb.call(this.scope)) } get y() { return this._y } set y(t) { this._y !== t && (this._y = t, this._quatDirtyId++, this.cb.call(this.scope)) } get z() { return this._z } set z(t) { this._z !== t && (this._z = t, this._quatDirtyId++, this.cb.call(this.scope)) } get pitch() { return this._x } set pitch(t) { this._x !== t && (this._x = t, this._quatDirtyId++, this.cb.call(this.scope)) } get yaw() { return this._y } set yaw(t) { this._y !== t && (this._y = t, this._quatDirtyId++, this.cb.call(this.scope)) } get roll() { return this._z } set roll(t) { this._z !== t && (this._z = t, this._quatDirtyId++, this.cb.call(this.scope)) } set(t, e, r) { const i = t || 0, s = e || 0, a = r || 0; return (this._x !== i || this._y !== s || this._z !== a) && (this._x = i, this._y = s, this._z = a, this._quatDirtyId++, this.cb.call(this.scope)), this } copyFrom(t) { const e = t.x, r = t.y, i = t.z; return (this._x !== e || this._y !== r || this._z !== i) && (this._x = e, this._y = r, this._z = i, this._quatDirtyId++, this.cb.call(this.scope)), this } copyTo(t) { return t.set(this._x, this._y, this._z), t } equals(t) { return this._x === t.x && this._y === t.y && this._z === t.z } clone() { return new _t(this._x, this._y, this._z) } update() { if (this._quatUpdateId === this._quatDirtyId) return !1; this._quatUpdateId = this._quatDirtyId; const t = Math.cos(this._x / 2), e = Math.cos(this._y / 2), r = Math.cos(this._z / 2), i = this._sign, s = i * Math.sin(this._x / 2), a = i * Math.sin(this._y / 2), o = i * Math.sin(this._z / 2), n = this.quaternion; return n[0] = s * e * r + t * a * o, n[1] = t * a * r - s * e * o, n[2] = t * e * o + s * a * r, n[3] = t * e * r - s * a * o, !0 } } const yt = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], ft = class { constructor(t) { this.floatArray = null, this._dirtyId = 0, this._updateId = -1, this._mat4inv = null, this.cacheInverse = !1, this.mat4 = new Float64Array(t || yt) } get a() { return this.mat4[0] / this.mat4[15] } set a(t) { this.mat4[0] = t * this.mat4[15] } get b() { return this.mat4[1] / this.mat4[15] } set b(t) { this.mat4[1] = t * this.mat4[15] } get c() { return this.mat4[4] / this.mat4[15] } set c(t) { this.mat4[4] = t * this.mat4[15] } get d() { return this.mat4[5] / this.mat4[15] } set d(t) { this.mat4[5] = t * this.mat4[15] } get tx() { return this.mat4[12] / this.mat4[15] } set tx(t) { this.mat4[12] = t * this.mat4[15] } get ty() { return this.mat4[13] / this.mat4[15] } set ty(t) { this.mat4[13] = t * this.mat4[15] } set(t, e, r, i, s, a) { const o = this.mat4; return o[0] = t, o[1] = e, o[2] = 0, o[3] = 0, o[4] = r, o[5] = i, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = s, o[13] = a, o[14] = 0, o[15] = 1, this } toArray(t, e) { this.floatArray || (this.floatArray = new Float32Array(9)); const r = e || this.floatArray, i = this.mat4; return t ? (r[0] = i[0], r[1] = i[1], r[2] = i[3], r[3] = i[4], r[4] = i[5], r[5] = i[7], r[6] = i[12], r[7] = i[13], r[8] = i[15]) : (r[0] = i[0], r[1] = i[4], r[2] = i[12], r[3] = i[2], r[4] = i[6], r[5] = i[13], r[6] = i[3], r[7] = i[7], r[8] = i[15]), r } setToTranslation(t, e, r) { const i = this.mat4; i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = t, i[13] = e, i[14] = r, i[15] = 1 } setToRotationTranslationScale(t, e, r, i, s, a, o) { const n = this.mat4, h = t[0], l = t[1], c = t[2], u = t[3], d = h + h, p = l + l, _ = c + c, m = h * d, y = h * p, f = h * _, x = l * p, T = l * _, v = c * _, I = u * d, g = u * p, E = u * _; return n[0] = (1 - (x + v)) * s, n[1] = (y + E) * s, n[2] = (f - g) * s, n[3] = 0, n[4] = (y - E) * a, n[5] = (1 - (m + v)) * a, n[6] = (T + I) * a, n[7] = 0, n[8] = (f + g) * o, n[9] = (T - I) * o, n[10] = (1 - (m + x)) * o, n[11] = 0, n[12] = e, n[13] = r, n[14] = i, n[15] = 1, n } apply(t, e) { e = e || new dt; const r = this.mat4, i = t.x, s = t.y, a = t.z || 0, o = 1 / (r[3] * i + r[7] * s + r[11] * a + r[15]); return e.x = o * (r[0] * i + r[4] * s + r[8] * a + r[12]), e.y = o * (r[1] * i + r[5] * s + r[9] * a + r[13]), e.z = o * (r[2] * i + r[6] * s + r[10] * a + r[14]), e } translate(t, e, r) { const i = this.mat4; return i[12] = i[0] * t + i[4] * e + i[8] * r + i[12], i[13] = i[1] * t + i[5] * e + i[9] * r + i[13], i[14] = i[2] * t + i[6] * e + i[10] * r + i[14], i[15] = i[3] * t + i[7] * e + i[11] * r + i[15], this } scale(t, e, r) { const i = this.mat4; return i[0] *= t, i[1] *= t, i[2] *= t, i[3] *= t, i[4] *= e, i[5] *= e, i[6] *= e, i[7] *= e, void 0 !== r && (i[8] *= r, i[9] *= r, i[10] *= r, i[11] *= r), this } scaleAndTranslate(t, e, r, i, s, a) { const o = this.mat4; o[0] = t * o[0] + i * o[3], o[1] = e * o[1] + s * o[3], o[2] = r * o[2] + a * o[3], o[4] = t * o[4] + i * o[7], o[5] = e * o[5] + s * o[7], o[6] = r * o[6] + a * o[7], o[8] = t * o[8] + i * o[11], o[9] = e * o[9] + s * o[11], o[10] = r * o[10] + a * o[11], o[12] = t * o[12] + i * o[15], o[13] = e * o[13] + s * o[15], o[14] = r * o[14] + a * o[15] } applyInverse(t, e) { e = e || new dt, this._mat4inv || (this._mat4inv = new Float64Array(16)); const r = this._mat4inv, i = this.mat4, s = t.x, a = t.y; let o = t.z || 0; (!this.cacheInverse || this._updateId !== this._dirtyId) && (this._updateId = this._dirtyId, ft.glMatrixMat4Invert(r, i)); const n = 1 / (r[3] * s + r[7] * a + r[11] * o + r[15]), h = n * (r[0] * s + r[4] * a + r[8] * o + r[12]), l = n * (r[1] * s + r[5] * a + r[9] * o + r[13]), c = n * (r[2] * s + r[6] * a + r[10] * o + r[14]); o += 1; const u = 1 / (r[3] * s + r[7] * a + r[11] * o + r[15]), d = u * (r[0] * s + r[4] * a + r[8] * o + r[12]), p = u * (r[1] * s + r[5] * a + r[9] * o + r[13]), _ = u * (r[2] * s + r[6] * a + r[10] * o + r[14]); Math.abs(c - _) < 1e-10 && e.set(NaN, NaN, 0); const m = (0 - c) / (_ - c); return e.set((d - h) * m + h, (p - l) * m + l, 0), e } invert() { return ft.glMatrixMat4Invert(this.mat4, this.mat4), this } invertCopyTo(t) { this._mat4inv || (this._mat4inv = new Float64Array(16)); const e = this._mat4inv, r = this.mat4; (!this.cacheInverse || this._updateId !== this._dirtyId) && (this._updateId = this._dirtyId, ft.glMatrixMat4Invert(e, r)), t.mat4.set(e) } identity() { const t = this.mat4; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } clone() { return new ft(this.mat4) } copyTo3d(t) { const e = this.mat4, r = t.mat4; return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], t } copyTo2d(t) { const e = this.mat4, r = t.mat3; return r[0] = e[0], r[1] = e[1], r[2] = e[3], r[3] = e[4], r[4] = e[5], r[5] = e[7], r[6] = e[12], r[7] = e[13], r[8] = e[15], t } copyTo2dOr3d(t) { return t instanceof X ? this.copyTo2d(t) : this.copyTo3d(t) } copyTo(t, e, r) { const i = this.mat4, s = 1 / i[15], a = i[12] * s, o = i[13] * s; if (t.a = (i[0] - i[3] * a) * s, t.b = (i[1] - i[3] * o) * s, t.c = (i[4] - i[7] * a) * s, t.d = (i[5] - i[7] * o) * s, t.tx = a, t.ty = o, e >= 2) { let i = t.a * t.d - t.b * t.c; r || (i = Math.abs(i)), e === O.POINT ? (i = i > 0 ? 1 : -1, t.a = i, t.b = 0, t.c = 0, t.d = i) : e === O.AXIS_X ? (i /= Math.sqrt(t.b * t.b + t.d * t.d), t.c = 0, t.d = i) : e === O.AXIS_Y && (i /= Math.sqrt(t.a * t.a + t.c * t.c), t.a = i, t.c = 0) } return t } copyFrom(t) { const e = this.mat4; return e[0] = t.a, e[1] = t.b, e[2] = 0, e[3] = 0, e[4] = t.c, e[5] = t.d, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t.tx, e[13] = t.ty, e[14] = 0, e[15] = 1, this._dirtyId++, this } setToMultLegacy(t, e) { const r = this.mat4, i = e.mat4, s = t.a, a = t.b, o = t.c, n = t.d, h = t.tx, l = t.ty; let c = i[0], u = i[1], d = i[2], p = i[3]; return r[0] = c * s + u * o + p * h, r[1] = c * a + u * n + p * l, r[2] = d, r[3] = p, c = i[4], u = i[5], d = i[6], p = i[7], r[4] = c * s + u * o + p * h, r[5] = c * a + u * n + p * l, r[6] = d, r[7] = p, c = i[8], u = i[9], d = i[10], p = i[11], r[8] = c * s + u * o + p * h, r[9] = c * a + u * n + p * l, r[10] = d, r[11] = p, c = i[12], u = i[13], d = i[14], p = i[15], r[12] = c * s + u * o + p * h, r[13] = c * a + u * n + p * l, r[14] = d, r[15] = p, this._dirtyId++, this } setToMultLegacy2(t, e) { const r = this.mat4, i = t.mat4, s = i[0], a = i[1], o = i[2], n = i[3], h = i[4], l = i[5], c = i[6], u = i[7], d = e.a, p = e.b, _ = e.c, m = e.d, y = e.tx, f = e.ty; return r[0] = d * s + p * h, r[1] = d * a + p * l, r[2] = d * o + p * c, r[3] = d * n + p * u, r[4] = _ * s + m * h, r[5] = _ * a + m * l, r[6] = _ * o + m * c, r[7] = _ * n + m * u, r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = y * s + f * h + i[12], r[13] = y * a + f * l + i[13], r[14] = y * o + f * c + i[14], r[15] = y * n + f * u + i[15], this._dirtyId++, this } setToMult(t, e) { return ft.glMatrixMat4Multiply(this.mat4, t.mat4, e.mat4), this._dirtyId++, this } prepend(t) { t.mat4 ? this.setToMult(t, this) : this.setToMultLegacy(t, this) } static glMatrixMat4Invert(t, e) { const r = e[0], i = e[1], s = e[2], a = e[3], o = e[4], n = e[5], h = e[6], l = e[7], c = e[8], u = e[9], d = e[10], p = e[11], _ = e[12], m = e[13], y = e[14], f = e[15], x = r * n - i * o, T = r * h - s * o, v = r * l - a * o, I = i * h - s * n, g = i * l - a * n, E = s * l - a * h, w = c * m - u * _, D = c * y - d * _, M = c * f - p * _, A = u * y - d * m, N = u * f - p * m, P = d * f - p * y; let S = x * P - T * N + v * A + I * M - g * D + E * w; return S ? (S = 1 / S, t[0] = (n * P - h * N + l * A) * S, t[1] = (s * N - i * P - a * A) * S, t[2] = (m * E - y * g + f * I) * S, t[3] = (d * g - u * E - p * I) * S, t[4] = (h * M - o * P - l * D) * S, t[5] = (r * P - s * M + a * D) * S, t[6] = (y * v - _ * E - f * T) * S, t[7] = (c * E - d * v + p * T) * S, t[8] = (o * N - n * M + l * w) * S, t[9] = (i * M - r * N - a * w) * S, t[10] = (_ * g - m * v + f * x) * S, t[11] = (u * v - c * g - p * x) * S, t[12] = (n * D - o * A - h * w) * S, t[13] = (r * A - i * D + s * w) * S, t[14] = (m * T - _ * I - y * x) * S, t[15] = (c * I - u * T + d * x) * S, t) : null } static glMatrixMat4Multiply(t, e, r) { const i = e[0], s = e[1], a = e[2], o = e[3], n = e[4], h = e[5], l = e[6], c = e[7], u = e[8], d = e[9], p = e[10], _ = e[11], m = e[12], y = e[13], f = e[14], x = e[15]; let T = r[0], v = r[1], I = r[2], g = r[3]; return t[0] = T * i + v * n + I * u + g * m, t[1] = T * s + v * h + I * d + g * y, t[2] = T * a + v * l + I * p + g * f, t[3] = T * o + v * c + I * _ + g * x, T = r[4], v = r[5], I = r[6], g = r[7], t[4] = T * i + v * n + I * u + g * m, t[5] = T * s + v * h + I * d + g * y, t[6] = T * a + v * l + I * p + g * f, t[7] = T * o + v * c + I * _ + g * x, T = r[8], v = r[9], I = r[10], g = r[11], t[8] = T * i + v * n + I * u + g * m, t[9] = T * s + v * h + I * d + g * y, t[10] = T * a + v * l + I * p + g * f, t[11] = T * o + v * c + I * _ + g * x, T = r[12], v = r[13], I = r[14], g = r[15], t[12] = T * i + v * n + I * u + g * m, t[13] = T * s + v * h + I * d + g * y, t[14] = T * a + v * l + I * p + g * f, t[15] = T * o + v * c + I * _ + g * x, t } }; let xt = ft; xt.IDENTITY = new ft, xt.TEMP_MATRIX = new ft; const Tt = new xt; class vt extends U { constructor(t, e) { super(t, e), this.cameraMatrix = null, this._cameraMode = !1, this.position = new pt(this.onChange, this, 0, 0), this.scale = new pt(this.onChange, this, 1, 1), this.euler = new mt(this.onChange, this, 0, 0, 0), this.pivot = new pt(this.onChange, this, 0, 0), this.local = new xt, this.world = new xt, this.local.cacheInverse = !0, this.world.cacheInverse = !0, this.position._z = 0, this.scale._z = 1, this.pivot._z = 0 } get cameraMode() { return this._cameraMode } set cameraMode(t) { this._cameraMode !== t && (this._cameraMode = t, this.euler._sign = this._cameraMode ? -1 : 1, this.euler._quatDirtyId++, t && (this.cameraMatrix = new xt)) } onChange() { this._projID++ } clear() { this.cameraMatrix && this.cameraMatrix.identity(), this.position.set(0, 0, 0), this.scale.set(1, 1, 1), this.euler.set(0, 0, 0), this.pivot.set(0, 0, 0), super.clear() } updateLocalTransform(t) { if (0 === this._projID) return void this.local.copyFrom(t); const e = this.local, r = this.euler, i = this.position, s = this.scale, a = this.pivot; if (r.update(), !this.cameraMode) return e.setToRotationTranslationScale(r.quaternion, i._x, i._y, i._z, s._x, s._y, s._z), e.translate(-a._x, -a._y, -a._z), void e.setToMultLegacy(t, e); e.setToMultLegacy(t, this.cameraMatrix), e.translate(a._x, a._y, a._z), e.scale(1 / s._x, 1 / s._y, 1 / s._z), Tt.setToRotationTranslationScale(r.quaternion, 0, 0, 0, 1, 1, 1), e.setToMult(e, Tt), e.translate(-i._x, -i._y, -i._z), this.local._dirtyId++ } } function It() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } class gt extends s.Container { constructor() { super(), this.proj = new vt(this.transform) } isFrontFace(t = !1) { t && (this._recursivePostUpdateTransform(), this.displayObjectUpdateTransform()); const e = this.proj.world.mat4, r = e[0] * e[15] - e[3] * e[12], i = e[1] * e[15] - e[3] * e[13], s = e[4] * e[15] - e[7] * e[12]; return r * (e[5] * e[15] - e[7] * e[13]) - s * i > 0 } getDepth(t = !1) { t && (this._recursivePostUpdateTransform(), this.displayObjectUpdateTransform()); const e = this.proj.world.mat4; return e[14] / e[15] } toLocal(t, e, r, i, s = C.ALL) { return e && (t = e.toGlobal(t, r, i)), i || this._recursivePostUpdateTransform(), s === C.ALL ? (i || this.displayObjectUpdateTransform(), this.proj.affine ? this.transform.worldTransform.applyInverse(t, r) : this.proj.world.applyInverse(t, r)) : (this.parent ? r = this.parent.worldTransform.applyInverse(t, r) : (r.x = t.x, r.y = t.y, r.z = t.z), s === C.NONE || (r = this.transform.localTransform.applyInverse(r, r), s === C.PROJ && this.proj.cameraMode && (r = this.proj.cameraMatrix.applyInverse(r, r))), r) } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } get position3d() { return this.proj.position } set position3d(t) { this.proj.position.copyFrom(t) } get scale3d() { return this.proj.scale } set scale3d(t) { this.proj.scale.copyFrom(t) } get euler() { return this.proj.euler } set euler(t) { this.proj.euler.copyFrom(t) } get pivot3d() { return this.proj.pivot } set pivot3d(t) { this.proj.pivot.copyFrom(t) } } const Et = gt.prototype.toLocal, wt = gt.prototype.getDepth, Dt = gt.prototype.isFrontFace; class Mt extends o.Mesh { constructor(t, e, r, i) { super(t, e, r, i), this.vertexData2d = null, this.proj = new vt(this.transform) } calculateVertices() { if (this.proj._affine) return this.vertexData2d = null, void super.calculateVertices(); const t = this.geometry, e = t.buffers[0].data, r = this; if (t.vertexDirtyId === r.vertexDirty && r._transformID === r.transform._worldID) return; r._transformID = r.transform._worldID, r.vertexData.length !== e.length && (r.vertexData = new Float32Array(e.length)), (!this.vertexData2d || this.vertexData2d.length !== 3 * e.length / 2) && (this.vertexData2d = new Float32Array(3 * e.length)); const i = this.proj.world.mat4, s = this.vertexData2d, a = r.vertexData; for (let t = 0; t < a.length / 2; t++) { const r = e[2 * t], o = e[2 * t + 1], n = i[0] * r + i[4] * o + i[12], h = i[1] * r + i[5] * o + i[13], l = i[3] * r + i[7] * o + i[15]; s[3 * t] = n, s[3 * t + 1] = h, s[3 * t + 2] = l, a[2 * t] = n / l, a[2 * t + 1] = h / l } r.vertexDirty = t.vertexDirtyId } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } toLocal(t, e, r, i, s = C.ALL) { return Et.call(this, t, e, r, i, s) } isFrontFace(t) { return Dt.call(this, t) } getDepth(t) { return wt.call(this, t) } get position3d() { return this.proj.position } set position3d(t) { this.proj.position.copyFrom(t) } get scale3d() { return this.proj.scale } set scale3d(t) { this.proj.scale.copyFrom(t) } get euler() { return this.proj.euler } set euler(t) { this.proj.euler.copyFrom(t) } get pivot3d() { return this.proj.pivot } set pivot3d(t) { this.proj.pivot.copyFrom(t) } } Mt.prototype._renderDefault = et.prototype._renderDefault; class At extends Mt { constructor(t, r, i, s, a) { super(new o.MeshGeometry(r, i, s), new o.MeshMaterial(t, { program: e.Program.from(et.defaultVertexShader, et.defaultFragmentShader), pluginName: "batch2d" }), null, a), this.autoUpdate = !0, this.geometry.getBuffer("aVertexPosition").static = !1 } get vertices() { return this.geometry.getBuffer("aVertexPosition").data } set vertices(t) { this.geometry.getBuffer("aVertexPosition").data = t } _render(t) { this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(t) } } class Nt extends h.Sprite { constructor(t) { super(t), this.vertexData2d = null, this.culledByFrustrum = !1, this.trimmedCulledByFrustrum = !1, this.proj = new vt(this.transform), this.pluginName = "batch2d" } calculateVertices() { const t = this._texture; if (this.proj._affine) return this.vertexData2d = null, void super.calculateVertices(); this.vertexData2d || (this.vertexData2d = new Float32Array(12)); const e = this.transform._worldID, r = t._updateID; if (this._transformID === e && this._textureID === r) return; this._textureID !== r && (this.uvs = t._uvs.uvsFloat32), this._transformID = e, this._textureID = r; const i = this.proj.world.mat4, s = this.vertexData2d, a = this.vertexData, o = t.trim, n = t.orig, h = this._anchor; let l, c, u, d; o ? (c = o.x - h._x * n.width, l = c + o.width, d = o.y - h._y * n.height, u = d + o.height) : (c = -h._x * n.width, l = c + n.width, d = -h._y * n.height, u = d + n.height); let p, _ = !1; s[0] = i[0] * c + i[4] * d + i[12], s[1] = i[1] * c + i[5] * d + i[13], p = i[2] * c + i[6] * d + i[14], s[2] = i[3] * c + i[7] * d + i[15], _ = _ || p < 0, s[3] = i[0] * l + i[4] * d + i[12], s[4] = i[1] * l + i[5] * d + i[13], p = i[2] * l + i[6] * d + i[14], s[5] = i[3] * l + i[7] * d + i[15], _ = _ || p < 0, s[6] = i[0] * l + i[4] * u + i[12], s[7] = i[1] * l + i[5] * u + i[13], p = i[2] * l + i[6] * u + i[14], s[8] = i[3] * l + i[7] * u + i[15], _ = _ || p < 0, s[9] = i[0] * c + i[4] * u + i[12], s[10] = i[1] * c + i[5] * u + i[13], p = i[2] * c + i[6] * u + i[14], s[11] = i[3] * c + i[7] * u + i[15], _ = _ || p < 0, this.culledByFrustrum = _, a[0] = s[0] / s[2], a[1] = s[1] / s[2], a[2] = s[3] / s[5], a[3] = s[4] / s[5], a[4] = s[6] / s[8], a[5] = s[7] / s[8], a[6] = s[9] / s[11], a[7] = s[10] / s[11] } calculateTrimmedVertices() { if (this.proj._affine) return void super.calculateTrimmedVertices(); const t = this.transform._worldID, e = this._texture._updateID, r = this; if (r.vertexTrimmedData) { if (r._transformTrimmedID === t && this._textureTrimmedID === e) return } else r.vertexTrimmedData = new Float32Array(8); r._transformTrimmedID = t, this._textureTrimmedID = e; const i = this._texture, s = r.vertexTrimmedData, a = i.orig, o = this._anchor, n = this.proj.world.mat4, h = -o._x * a.width, l = h + a.width, c = -o._y * a.height, u = c + a.height; let d, p = !1, _ = 1 / (n[3] * h + n[7] * c + n[15]); s[0] = _ * (n[0] * h + n[4] * c + n[12]), s[1] = _ * (n[1] * h + n[5] * c + n[13]), d = n[2] * h + n[6] * c + n[14], p = p || d < 0, _ = 1 / (n[3] * l + n[7] * c + n[15]), s[2] = _ * (n[0] * l + n[4] * c + n[12]), s[3] = _ * (n[1] * l + n[5] * c + n[13]), d = n[2] * l + n[6] * c + n[14], p = p || d < 0, _ = 1 / (n[3] * l + n[7] * u + n[15]), s[4] = _ * (n[0] * l + n[4] * u + n[12]), s[5] = _ * (n[1] * l + n[5] * u + n[13]), d = n[2] * l + n[6] * u + n[14], p = p || d < 0, _ = 1 / (n[3] * h + n[7] * u + n[15]), s[6] = _ * (n[0] * h + n[4] * u + n[12]), s[7] = _ * (n[1] * h + n[5] * u + n[13]), d = n[2] * h + n[6] * u + n[14], p = p || d < 0, this.culledByFrustrum = p } _calculateBounds() { if (this.calculateVertices(), this.culledByFrustrum) return; const t = this._texture.trim, e = this._texture.orig; !t || t.width === e.width && t.height === e.height ? this._bounds.addQuad(this.vertexData) : (this.calculateTrimmedVertices(), this.trimmedCulledByFrustrum || this._bounds.addQuad(this.vertexTrimmedData)) } _render(t) { this.calculateVertices(), !this.culledByFrustrum && (t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)) } containsPoint(t) { return !this.culledByFrustrum && super.containsPoint(t) } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } toLocal(t, e, r, i, s = C.ALL) { return Et.call(this, t, e, r, i, s) } isFrontFace(t) { return Dt.call(this, t) } getDepth(t) { return wt.call(this, t) } get position3d() { return this.proj.position } set position3d(t) { this.proj.position.copyFrom(t) } get scale3d() { return this.proj.scale } set scale3d(t) { this.proj.scale.copyFrom(t) } get euler() { return this.proj.euler } set euler(t) { this.proj.euler.copyFrom(t) } get pivot3d() { return this.proj.pivot } set pivot3d(t) { this.proj.pivot.copyFrom(t) } } const Pt = { worldTransform: { get: It, enumerable: !0, configurable: !0 }, position3d: { get() { return this.proj.position }, set(t) { this.proj.position.copy(t) } }, scale3d: { get() { return this.proj.scale }, set(t) { this.proj.scale.copy(t) } }, pivot3d: { get() { return this.proj.pivot }, set(t) { this.proj.pivot.copy(t) } }, euler: { get() { return this.proj.euler }, set(t) { this.proj.euler.copy(t) } } }; function St() { this.proj || (this.proj = new vt(this.transform), this.toLocal = gt.prototype.toLocal, this.isFrontFace = gt.prototype.isFrontFace, this.getDepth = gt.prototype.getDepth, Object.defineProperties(this, Pt)) } s.Container.prototype.convertTo3d = St, h.Sprite.prototype.convertTo3d = function () { this.proj || (this.calculateVertices = Nt.prototype.calculateVertices, this.calculateTrimmedVertices = Nt.prototype.calculateTrimmedVertices, this._calculateBounds = Nt.prototype._calculateBounds, this.containsPoint = Nt.prototype.containsPoint, this.pluginName = "batch2d", St.call(this)) }, s.Container.prototype.convertSubtreeTo3d = function () { this.convertTo3d(); for (let t = 0; t < this.children.length; t++)this.children[t].convertSubtreeTo3d() }, n.SimpleMesh.prototype.convertTo3d = n.SimpleRope.prototype.convertTo3d = function () { this.proj || (this.calculateVertices = Mt.prototype.calculateVertices, this._renderDefault = Mt.prototype._renderDefault, "batch2d" !== this.material.pluginName && (this.material = new o.MeshMaterial(this.material.texture, { program: e.Program.from(et.defaultVertexShader, et.defaultFragmentShader), pluginName: "batch2d" })), St.call(this)) }; class Rt extends l.Text { constructor(t, e, r) { super(t, e, r), this.vertexData2d = null, this.proj = new vt(this.transform), this.pluginName = "batch2d" } get worldTransform() { return this.proj.affine ? this.transform.worldTransform : this.proj.world } toLocal(t, e, r, i, s = C.ALL) { return Et.call(this, t, e, r, i, s) } isFrontFace(t) { return Dt.call(this, t) } getDepth(t) { return wt.call(this, t) } get position3d() { return this.proj.position } set position3d(t) { this.proj.position.copyFrom(t) } get scale3d() { return this.proj.scale } set scale3d(t) { this.proj.scale.copyFrom(t) } get euler() { return this.proj.euler } set euler(t) { this.proj.euler.copyFrom(t) } get pivot3d() { return this.proj.pivot } set pivot3d(t) { this.proj.pivot.copyFrom(t) } } Rt.prototype.calculateVertices = Nt.prototype.calculateVertices, Rt.prototype.calculateTrimmedVertices = Nt.prototype.calculateTrimmedVertices, Rt.prototype._calculateBounds = Nt.prototype._calculateBounds, Rt.prototype.containsPoint = Nt.prototype.containsPoint, Rt.prototype._render = Nt.prototype._render; class bt extends e.Geometry { constructor(t = !1) { super(), this._buffer = new e.Buffer(null, t, !1), this._indexBuffer = new e.Buffer(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, T.FLOAT).addAttribute("aTrans1", this._buffer, 3, !1, T.FLOAT).addAttribute("aTrans2", this._buffer, 3, !1, T.FLOAT).addAttribute("aSamplerSize", this._buffer, 2, !1, T.FLOAT).addAttribute("aFrame", this._buffer, 4, !1, T.FLOAT).addAttribute("aColor", this._buffer, 4, !0, T.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, T.FLOAT).addIndex(this._indexBuffer) } } class jt extends B { constructor(t) { super(t), this.defUniforms = { translationMatrix: new r.Matrix, distortion: new Float32Array([0, 0, 1 / 0, 1 / 0]) }, this.size = 1e3, this.forceMaxTextures = 1, this.vertexSize = 16, this.geometryClass = bt } setShaderGenerator() { this.shaderGenerator = new e.BatchShaderGenerator("precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec3 aTrans1;\nattribute vec3 aTrans2;\nattribute vec2 aSamplerSize;\nattribute vec4 aFrame;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\ngl_Position.z = 0.0;\n\nvertexPosition = aVertexPosition;\nvTrans1 = aTrans1;\nvTrans2 = aTrans2;\nvTextureId = aTextureId;\nvColor = aColor;\nvSamplerSize = aSamplerSize;\nvFrame = aFrame;\n}\n", "precision highp float;\nvarying vec2 vertexPosition;\nvarying vec3 vTrans1;\nvarying vec3 vTrans2;\nvarying vec2 vSamplerSize;\nvarying vec4 vFrame;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\nuniform vec4 distortion;\n\nvoid main(void){\nvec2 surface;\nvec2 surface2;\n\nfloat vx = vertexPosition.x;\nfloat vy = vertexPosition.y;\nfloat dx = distortion.x;\nfloat dy = distortion.y;\nfloat revx = distortion.z;\nfloat revy = distortion.w;\n\nif (distortion.x == 0.0) {\nsurface.x = vx;\nsurface.y = vy / (1.0 + dy * vx);\nsurface2 = surface;\n} else\nif (distortion.y == 0.0) {\nsurface.y = vy;\nsurface.x = vx / (1.0 + dx * vy);\nsurface2 = surface;\n} else {\nfloat c = vy * dx - vx * dy;\nfloat b = (c + 1.0) * 0.5;\nfloat b2 = (-c + 1.0) * 0.5;\nfloat d = b * b + vx * dy;\nif (d < -0.00001) {\n    discard;\n}\nd = sqrt(max(d, 0.0));\nsurface.x = (- b + d) * revy;\nsurface2.x = (- b - d) * revy;\nsurface.y = (- b2 + d) * revx;\nsurface2.y = (- b2 - d) * revx;\n}\n\nvec2 uv;\nuv.x = vTrans1.x * surface.x + vTrans1.y * surface.y + vTrans1.z;\nuv.y = vTrans2.x * surface.x + vTrans2.y * surface.y + vTrans2.z;\n\nvec2 pixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\npixels.y < vFrame.y || pixels.y > vFrame.w) {\nuv.x = vTrans1.x * surface2.x + vTrans1.y * surface2.y + vTrans1.z;\nuv.y = vTrans2.x * surface2.x + vTrans2.y * surface2.y + vTrans2.z;\npixels = uv * vSamplerSize;\n\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\n   pixels.y < vFrame.y || pixels.y > vFrame.w) {\n   discard;\n}\n}\n\nvec4 edge;\nedge.xy = clamp(pixels - vFrame.xy + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\nedge.zw = clamp(vFrame.zw - pixels + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\n\nfloat alpha = 1.0; //edge.x * edge.y * edge.z * edge.w;\nvec4 rColor = vColor * alpha;\n\nfloat textureId = floor(vTextureId+0.5);\nvec2 vTextureCoord = uv;\nvec4 color;\n%forloop%\ngl_FragColor = color * rColor;\n}") } getUniforms(t) { const { proj: e } = t; return null !== e.surface ? e.uniforms : null !== e._activeProjection ? e._activeProjection.uniforms : this.defUniforms } packInterleavedGeometry(t, r, i, s, a) { const { uint32View: o, float32View: n } = r, h = s / this.vertexSize, l = t.indices, c = t.vertexData, u = t._texture._frame, d = t.aTrans, { _batchLocation: p, realWidth: _, realHeight: m, resolution: y } = t._texture.baseTexture, f = Math.min(t.worldAlpha, 1), x = e.Color.shared.setValue(t._tintRGB).toPremultiplied(f); for (let t = 0; t < c.length; t += 2)n[s] = c[t], n[s + 1] = c[t + 1], n[s + 2] = d.a, n[s + 3] = d.c, n[s + 4] = d.tx, n[s + 5] = d.b, n[s + 6] = d.d, n[s + 7] = d.ty, n[s + 8] = _, n[s + 9] = m, n[s + 10] = u.x * y, n[s + 11] = u.y * y, n[s + 12] = (u.x + u.width) * y, n[s + 13] = (u.y + u.height) * y, o[s + 14] = x, n[s + 15] = p, s += 16; for (let t = 0; t < l.length; t++)i[a++] = h + l[t] } } jt.extension = { name: "batch_bilinear", type: e.ExtensionType.RendererPlugin }; const Lt = [new r.Point, new r.Point, new r.Point, new r.Point], Ct = [0, 0, 0, 0]; class Ot { constructor() { this.surfaceID = "default", this._updateID = 0, this.vertexSrc = "", this.fragmentSrc = "" } fillUniforms(t) { } clear() { } boundsQuad(t, e, r) { let i = e[0], s = e[1], a = e[0], o = e[1]; for (let t = 2; t < 8; t += 2)i > e[t] && (i = e[t]), a < e[t] && (a = e[t]), s > e[t + 1] && (s = e[t + 1]), o < e[t + 1] && (o = e[t + 1]); if (Lt[0].set(i, s), this.apply(Lt[0], Lt[0]), Lt[1].set(a, s), this.apply(Lt[1], Lt[1]), Lt[2].set(a, o), this.apply(Lt[2], Lt[2]), Lt[3].set(i, o), this.apply(Lt[3], Lt[3]), r) r.apply(Lt[0], Lt[0]), r.apply(Lt[1], Lt[1]), r.apply(Lt[2], Lt[2]), r.apply(Lt[3], Lt[3]), e[0] = Lt[0].x, e[1] = Lt[0].y, e[2] = Lt[1].x, e[3] = Lt[1].y, e[4] = Lt[2].x, e[5] = Lt[2].y, e[6] = Lt[3].x, e[7] = Lt[3].y; else { for (let t = 1; t <= 3; t++)if (Lt[t].y < Lt[0].y || Lt[t].y === Lt[0].y && Lt[t].x < Lt[0].x) { const e = Lt[0]; Lt[0] = Lt[t], Lt[t] = e } for (let t = 1; t <= 3; t++)Ct[t] = Math.atan2(Lt[t].y - Lt[0].y, Lt[t].x - Lt[0].x); for (let t = 1; t <= 3; t++)for (let e = t + 1; e <= 3; e++)if (Ct[t] > Ct[e]) { const r = Lt[t]; Lt[t] = Lt[e], Lt[e] = r; const i = Ct[t]; Ct[t] = Ct[e], Ct[e] = i } if (e[0] = Lt[0].x, e[1] = Lt[0].y, e[2] = Lt[1].x, e[3] = Lt[1].y, e[4] = Lt[2].x, e[5] = Lt[2].y, e[6] = Lt[3].x, e[7] = Lt[3].y, (Lt[3].x - Lt[2].x) * (Lt[1].y - Lt[2].y) - (Lt[1].x - Lt[2].x) * (Lt[3].y - Lt[2].y) < 0) return e[4] = Lt[3].x, void (e[5] = Lt[3].y) } } } const Ft = new r.Matrix, Ut = new r.Rectangle, Bt = new r.Point; class Gt extends Ot { constructor() { super(...arguments), this.distortion = new r.Point } clear() { this.distortion.set(0, 0) } apply(t, e) { e = e || new r.Point; const i = this.distortion, s = t.x * t.y; return e.x = t.x + i.x * s, e.y = t.y + i.y * s, e } applyInverse(t, e) { e = e || new r.Point; const i = t.x, s = t.y, a = this.distortion.x, o = this.distortion.y; if (0 === a) e.x = i, e.y = s / (1 + o * i); else if (0 === o) e.y = s, e.x = i / (1 + a * s); else { const t = .5 * (s * a - i * o + 1) / o, r = t * t + i / o; if (r <= 1e-5) return e.set(NaN, NaN), e; e.x = o > 0 ? -t + Math.sqrt(r) : -t - Math.sqrt(r), e.y = (i / e.x - 1) / a } return e } mapSprite(t, e, r) { const i = t.texture; return Ut.x = -t.anchor.x * i.orig.width, Ut.y = -t.anchor.y * i.orig.height, Ut.width = i.orig.width, Ut.height = i.orig.height, this.mapQuad(Ut, e, r || t.transform) } mapQuad(t, e, r) { const i = -t.x / t.width, s = -t.y / t.height, a = (1 - t.x) / t.width, o = (1 - t.y) / t.height, n = e[0].x * (1 - i) + e[1].x * i, h = e[0].y * (1 - i) + e[1].y * i, l = e[0].x * (1 - a) + e[1].x * a, c = e[0].y * (1 - a) + e[1].y * a, u = e[3].x * (1 - i) + e[2].x * i, d = e[3].y * (1 - i) + e[2].y * i, p = e[3].x * (1 - a) + e[2].x * a, _ = e[3].y * (1 - a) + e[2].y * a, m = n * (1 - s) + u * s, y = h * (1 - s) + d * s, f = l * (1 - s) + p * s, x = c * (1 - s) + _ * s, T = n * (1 - o) + u * o, v = h * (1 - o) + d * o, I = l * (1 - o) + p * o, g = c * (1 - o) + _ * o, E = Ft; return E.tx = m, E.ty = y, E.a = f - m, E.b = x - y, E.c = T - m, E.d = v - y, Bt.set(I, g), E.applyInverse(Bt, Bt), this.distortion.set(Bt.x - 1, Bt.y - 1), r.setFromMatrix(E), this } fillUniforms(t) { t.distortion = t.distortion || new Float32Array([0, 0, 0, 0]); const e = Math.abs(this.distortion.x), r = Math.abs(this.distortion.y); t.distortion[0] = 1e4 * e <= r ? 0 : this.distortion.x, t.distortion[1] = 1e4 * r <= e ? 0 : this.distortion.y, t.distortion[2] = 1 / t.distortion[0], t.distortion[3] = 1 / t.distortion[1] } } const Vt = r.Transform.prototype.updateTransform; function zt(t) { const e = this.proj, r = t.proj, i = this; return r ? r._surface ? (e._activeProjection = r, this.updateLocalTransform(), this.localTransform.copyTo(this.worldTransform), void (i._parentID < 0 && ++i._worldID)) : (Vt.call(this, t), void (e._activeProjection = r._activeProjection)) : (Vt.call(this, t), void (e._activeProjection = null)) } class Xt extends L { constructor() { super(...arguments), this._surface = null, this._activeProjection = null, this._currentSurfaceID = -1, this._currentLegacyID = -1, this._lastUniforms = null } set enabled(t) { t !== this._enabled && (this._enabled = t, t ? (this.legacy.updateTransform = zt, this.legacy._parentID = -1) : (this.legacy.updateTransform = r.Transform.prototype.updateTransform, this.legacy._parentID = -1)) } get surface() { return this._surface } set surface(t) { this._surface !== t && (this._surface = t || null, this.legacy._parentID = -1) } applyPartial(t, e) { return null !== this._activeProjection ? (e = this.legacy.worldTransform.apply(t, e), this._activeProjection.surface.apply(e, e)) : null !== this._surface ? this.surface.apply(t, e) : this.legacy.worldTransform.apply(t, e) } apply(t, e) { return null !== this._activeProjection ? (e = this.legacy.worldTransform.apply(t, e), this._activeProjection.surface.apply(e, e), this._activeProjection.legacy.worldTransform.apply(e, e)) : null !== this._surface ? (e = this.surface.apply(t, e), this.legacy.worldTransform.apply(e, e)) : this.legacy.worldTransform.apply(t, e) } applyInverse(t, e) { return null !== this._activeProjection ? (e = this._activeProjection.legacy.worldTransform.applyInverse(t, e), this._activeProjection._surface.applyInverse(e, e), this.legacy.worldTransform.applyInverse(e, e)) : null !== this._surface ? (e = this.legacy.worldTransform.applyInverse(t, e), this._surface.applyInverse(e, e)) : this.legacy.worldTransform.applyInverse(t, e) } mapBilinearSprite(t, e) { this._surface instanceof Gt || (this.surface = new Gt), this.surface.mapSprite(t, e, this.legacy) } clear() { this.surface && this.surface.clear() } get uniforms() { return this._currentLegacyID === this.legacy._worldID && this._currentSurfaceID === this.surface._updateID || (this._lastUniforms = this._lastUniforms || {}, this._lastUniforms.translationMatrix = this.legacy.worldTransform, this._surface.fillUniforms(this._lastUniforms)), this._lastUniforms } } class qt extends h.Sprite { constructor(t) { super(t), this.aTrans = new r.Matrix, this.proj = new Xt(this.transform), this.pluginName = "batch_bilinear" } _calculateBounds() { this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData) } calculateVertices() { const t = this.transform._worldID, r = this._texture._updateID; if (this._transformID === t && this._textureID === r) return; this._transformID = t, this._textureID = r; const i = this._texture, s = this.vertexData, a = i.trim, o = i.orig, n = this._anchor; let h, l, c, u; if (a ? (l = a.x - n._x * o.width, h = l + a.width, u = a.y - n._y * o.height, c = u + a.height) : (l = -n._x * o.width, h = l + o.width, u = -n._y * o.height, c = u + o.height), this.proj._surface) s[0] = l, s[1] = u, s[2] = h, s[3] = u, s[4] = h, s[5] = c, s[6] = l, s[7] = c, this.proj._surface.boundsQuad(s, s); else { const t = this.transform.worldTransform, e = t.a, r = t.b, i = t.c, a = t.d, o = t.tx, n = t.ty; s[0] = e * l + i * u + o, s[1] = a * u + r * l + n, s[2] = e * h + i * u + o, s[3] = a * u + r * h + n, s[4] = e * h + i * c + o, s[5] = a * c + r * h + n, s[6] = e * l + i * c + o, s[7] = a * c + r * l + n, this.proj._activeProjection && this.proj._activeProjection.surface.boundsQuad(s, s) } i.uvMatrix || (i.uvMatrix = new e.TextureMatrix(i)), i.uvMatrix.update(); const d = this.aTrans; d.set(o.width, 0, 0, o.height, l, u), null === this.proj._surface && d.prepend(this.transform.worldTransform), d.invert(), d.prepend(i.uvMatrix.mapCoord) } calculateTrimmedVertices() { const t = this.transform._worldID, e = this._texture._updateID, r = this; if (r.vertexTrimmedData) { if (r._transformTrimmedID === t && this._textureTrimmedID === e) return } else r.vertexTrimmedData = new Float32Array(8); r._transformTrimmedID = t, this._textureTrimmedID = e; const i = this._texture, s = r.vertexTrimmedData, a = i.orig, o = this._anchor, n = -o._x * a.width, h = n + a.width, l = -o._y * a.height, c = l + a.height; if (this.proj._surface) s[0] = n, s[1] = l, s[2] = h, s[3] = l, s[4] = h, s[5] = c, s[6] = n, s[7] = c, this.proj._surface.boundsQuad(s, s, this.transform.worldTransform); else { const t = this.transform.worldTransform, e = t.a, r = t.b, i = t.c, a = t.d, o = t.tx, u = t.ty; s[0] = e * n + i * l + o, s[1] = a * l + r * n + u, s[2] = e * h + i * l + o, s[3] = a * l + r * h + u, s[4] = e * h + i * c + o, s[5] = a * c + r * h + u, s[6] = e * n + i * c + o, s[7] = a * c + r * n + u, this.proj._activeProjection && this.proj._activeProjection.surface.boundsQuad(s, s, this.proj._activeProjection.legacy.worldTransform) } } get worldTransform() { return this.proj } } h.Sprite.prototype.convertTo2s = function () { this.proj || (this.pluginName = "sprite_bilinear", this.aTrans = new r.Matrix, this.calculateVertices = qt.prototype.calculateVertices, this.calculateTrimmedVertices = qt.prototype.calculateTrimmedVertices, this._calculateBounds = qt.prototype._calculateBounds, s.Container.prototype.convertTo2s.call(this)) }, s.Container.prototype.convertTo2s = function () { this.proj || (this.proj = new Xt(this.transform), Object.defineProperty(this, "worldTransform", { get() { return this.proj }, enumerable: !0, configurable: !0 })) }, s.Container.prototype.convertSubtreeTo2s = function () { this.convertTo2s(); for (let t = 0; t < this.children.length; t++)this.children[t].convertSubtreeTo2s() }; class Ht extends l.Text { constructor(t, e, i) { super(t, e, i), this.aTrans = new r.Matrix, this.proj = new Xt(this.transform), this.pluginName = "batch_bilinear" } get worldTransform() { return this.proj } } return Ht.prototype.calculateVertices = qt.prototype.calculateVertices, Ht.prototype.calculateTrimmedVertices = qt.prototype.calculateTrimmedVertices, Ht.prototype._calculateBounds = qt.prototype._calculateBounds, e.extensions.add(jt), t.AFFINE = O, t.AbstractProjection = L, t.Batch2dRenderer = j, t.Batch3dGeometry = b, t.BatchBilinearGeometry = bt, t.BatchBilinearRenderer = jt, t.BilinearSurface = Gt, t.Camera3d = class extends gt { constructor() { super(), this._far = 0, this._near = 0, this._focus = 0, this._orthographic = !1, this.proj.cameraMode = !0, this.setPlanes(400, 10, 1e4, !1) } get far() { return this._far } get near() { return this._near } get focus() { return this._focus } get ortographic() { return this._orthographic } setPlanes(t, e = 10, r = 1e4, i = !1) { this._focus = t, this._near = e, this._far = r, this._orthographic = i; const s = this.proj, a = s.cameraMatrix.mat4; s._projID++, a[10] = 1 / (r - e), a[14] = (t - e) / (r - e), this._orthographic ? a[11] = 0 : a[11] = 1 / t } }, t.Container2d = $, t.Container3d = gt, t.Euler = _t, t.LinearProjection = U, t.Matrix2d = X, t.Matrix3d = xt, t.Mesh2d = et, t.Mesh3d2d = Mt, t.ObservableEuler = mt, t.ObservablePoint3d = pt, t.Point3d = dt, t.Projection2d = K, t.Projection3d = vt, t.ProjectionSurface = Xt, t.SimpleMesh2d = rt, t.SimpleMesh3d2d = At, t.Sprite2d = it, t.Sprite2s = qt, t.Sprite3d = Nt, t.SpriteMaskFilter2d = lt, t.Surface = Ot, t.TRANSFORM_STEP = C, t.Text2d = nt, t.Text2s = Ht, t.Text3d = Rt, t.TilingSprite2d = at, t.TilingSprite2dRenderer = k, t.UniformBatchRenderer = B, t.applySpine2dMixin = function (t) { t.newMesh = function (t, e, r, i, s) { return new rt(t, e, r, i, s) }, t.newContainer = function () { return this.proj || this.convertTo2d(), new $ }, t.newSprite = function (t) { return new it(t) }, t.newGraphics = function () { const t = new c.Graphics; return t.convertTo2d(), t }, t.transformHack = function () { return 2 } }, t.applySpine3dMixin = function (t) { t.newMesh = function (t, e, r, i, s) { return new At(t, e, r, i, s) }, t.newContainer = function () { return this.proj || this.convertTo3d(), new gt }, t.newSprite = function (t) { return new Nt(t) }, t.newGraphics = function () { const t = new c.Graphics; return t.convertTo3d(), t }, t.transformHack = function () { return 2 } }, t.container2dToLocal = tt, t.container2dWorldTransform = Z, t.container3dGetDepth = wt, t.container3dIsFrontFace = Dt, t.container3dToLocal = Et, t.container3dWorldTransform = It, t.getIntersectionFactor = G, t.getPositionFromQuad = function (t, e, i) { i = i || new r.Point; const s = 1 - e.x, a = 1 - s, o = 1 - e.y, n = 1 - o; return i.x = (t[0].x * s + t[1].x * a) * o + (t[3].x * s + t[2].x * a) * n, i.y = (t[0].y * s + t[1].y * a) * o + (t[3].y * s + t[2].y * a) * n, i }, t.patchSpriteMask = function () { e.MaskSystem.prototype.pushSpriteMask = ut }, t.transformHack = F, t }({}, PIXI, PIXI, PIXI.utils, PIXI, PIXI, PIXI, PIXI, PIXI, PIXI, PIXI);
//# sourceMappingURL=/sm/fab9a7361d6ac0d1e864e23246d99770a16add0075e21ebe796b5432ec32751c.map